#version 450

#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_8bit_storage : enable
#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer InputBuffer {
	uint8_t in_data[];
};

layout(set = 0, binding = 1) buffer PfacTableBuffer {
	uint pfac_table[];
};

layout(set = 0, binding = 2) buffer OutputBuffer {
	uint out_data[];
};

// ===

const uint64_t FNV_OFFSET_BASIS = 0xcbf29ce484222325ul;
const uint64_t FNV_PRIME = 0x100000001b3ul;

// ===

uint read_in(uint idx) {
	return uint(in_data[idx + 4]);
}

uint in_data_len() {
	return uint(in_data[0]) | (uint(in_data[1]) << 8) | (uint(in_data[2]) << 16) | (uint(in_data[3]) << 24);
}

bool pfac_table_lookup(uint state, uint value, out uint next_state) {
	// The pfac table len is u64 but we're going to assume it's not larger than u32 cause otherwise we can't handle it anyway
	uint pfac_table_rlen = pfac_table[0];
	uint row_idx = (state * pfac_table_rlen * 2) + 2;
	uint row_len = pfac_table[row_idx];

	// debugPrintfEXT("row_idx: %u, row_len: %u\n", row_idx, row_len);

	for(uint i = 2; i <= row_len * 2; i += 2) {
		uint idx = i + row_idx;
		uint elem_value = pfac_table[idx];
		uint elem_next_state = pfac_table[idx + 1];

		if(elem_value == value) {
			next_state = elem_next_state;
			return true;
		}

		// debugPrintfEXT("pfac_table[%u]: { next_state: %u, value: %u } (len of this row: %u)\n", idx, next_state, value, row_len);
	}

	// debugPrintfEXT("pfac_table_rlen: %u\n", pfac_table_rlen);

	next_state = 0;
	return false;
}

bool pfac_table_is_terminator(uint state) {
	// The pfac table len is u64 but we're going to assume it's not larger than u32 cause otherwise we can't handle it anyway
	uint pfac_table_rlen = pfac_table[0];
	uint row_idx = (state * pfac_table_rlen * 2) + 2;
	uint row_len = pfac_table[row_idx];

	return row_len == 0;
}

// start_idx and end_idx are relative to the current in_data
void write_match(uint64_t id, uint start_idx, uint end_idx) {
	uint idx = atomicAdd(out_data[0], 1);
	idx *= 4; // idx * data size in uints
	idx += 1; // offset from length at start
	uint out_data_len = 1024 * 1024;
	idx -= uint(idx > out_data_len) * (idx - out_data_len); // Branchless programming!
	// debugPrintfEXT("Writing match at idx: %u\n", idx);
	out_data[idx] = uint(id & 0x00000000ffffffff);
	out_data[idx + 1] = uint((id >> 32) & 0x00000000ffffffff);
	out_data[idx + 2] = start_idx;
	out_data[idx + 3] = end_idx;
}

// Carry-less multiplication, simply discards the overflowing bits of the result
uint64_t clmul(uint64_t x, uint64_t y) {
	uint64_t accum = 0;
	for(uint i = 0; i < 128; i++) {
		if((x & 1ul) == 1) {
			// NOTE: In glsl, while the result of multiplication with overflow is undefined, addition with overflow simply yields the lower bits of the result
			accum += y;
		}
		x >>= 1ul;
		x ^= x & (1ul << 127);
		y <<= 1ul;
		y ^= y & 1ul;
	}

	return accum;
}

uint64_t match_id_hash_init() {
	return FNV_OFFSET_BASIS;
}

uint64_t match_id_hash_add(uint64_t hash, uint new_value) {
	return clmul((hash ^ uint64_t(new_value)), FNV_PRIME);
}

// ===

void main() {
	uint idx = gl_GlobalInvocationID.x;
	uint in_data_len = in_data_len();

	uint state = 0;
	uint start_idx = idx;
	uint64_t id = match_id_hash_init();

	while(true) {
		if(idx >= in_data_len) {
			// TODO: Save running states if we are at/past the end of the input data
			break;
		}

		uint next_state = 0;
		uint data_idx = read_in(idx);
		if(pfac_table_lookup(state, data_idx, next_state)) {
			state = next_state;
			idx += 1;
			id = match_id_hash_add(id, data_idx);
			// debugPrintfEXT("[pfac.comp/INFO]: Lookup successful, changing state to %u\n", state);
		} else if(pfac_table_is_terminator(state)) {
			// debugPrintfEXT("[pfac.comp/INFO]: Found match at idx %u..%u\n", start_idx, idx - 1);
			write_match(id, start_idx, idx - 1);
			break;
		} else {
			break;
		}
	}
}